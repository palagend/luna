#general config
jdbc.username = root
jdbc.password = admin
hibernate.temp.use_jdbc_metadata_defaults=false
hibernate.show_sql=true
hibernate.format_sql=true
hibernate.max_fetch_depth=3
hibernate.jdbc.fetch_size=18
hibernate.jdbc.batch_size=10
hibernate.hbm2ddl.auto=update
#mysql config
hibernate.dialect=org.hibernate.dialect.MySQLDialect
jdbc.driverClassName = com.mysql.jdbc.Driver
jdbc.url = jdbc:mysql://localhost:3306/distribution_system?characterEncoding=utf8
#jdbc.url = jdbc:mysql://192.168.49.128:3306/test?useUnicode=true&amp;characterEncoding=utf8

#SQLServer config
#hibernate.dialect=org.hibernate.dialect.HSQLDialect
#jdbc.driverClassName=net.sourceforge.jtds.jdbc.Driver
#jdbc.url=jdbc:jtds:sqlserver://localhost:1433/test

#Oracle config
#hibernate.dialect=org.hibernate.dialect.Oracle10gDialect


#dataSource.className=oracle.jdbc.OracleDriver
#dataSource.url=jdbc\:oracle\:thin\:@//192.168.13.111\:1521/gongjiaodushi

# Time to wait for an open connection before timing out
# (in milliseconds)
cpool.checkoutTimeout=5000

# Connection pool size
cpool.minPoolSize=5
cpool.maxPoolSize=20

# How long to keep unused connections around(in seconds)
# Note: MySQL times out idle connections after 8 hours(28,800 seconds)
# so ensure this value is below MySQL idle timeout
cpool.maxIdleTime=36000

# How long to hang on to excess unused connections after traffic spike
# (in seconds)
cpool.maxIdleTimeExcessConnections=1800

# Acquiring new connections is slow, so eagerly retrieve extra connections
# when current pool size is reached
cpool.acquireIncrement=5

cpool.acquireRetryAttempts=0
cpool.acquireRetryDelay=1000
